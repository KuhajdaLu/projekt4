\documentclass[12pt]{article}
\usepackage{graphicx}
\usepackage[czech]{babel}
\usepackage[utf8]{inputenc}
\usepackage{titling}
\usepackage{pdfpages}
\usepackage[nopar]{lipsum}
\usepackage{mathtools}
\usepackage{multirow}
\usepackage{caption}
\usepackage{float}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\setlength{\parindent}{1cm}
\setlength{\hoffset}{-1.1cm} 
\setlength{\voffset}{-2cm}
\setlength{\textheight}{23.0cm} 
\setlength{\textwidth}{15cm}

\begin{document}
\title{Bakalářská práce}
\author{Lukáš Kuhajda}
\date{Akademický rok 2018/2019}
\begin{titlepage}
	\begin{center}
		\includegraphics[scale=0.5]{logo_zcu}\\
		\vspace{5cm}
		\begin{Large}
			\textbf{\thetitle}\\
		\end{Large}
		
		\vspace{3cm}
		\theauthor\\
		\vspace{5cm}
		\thedate
	\end{center}
\end{titlepage}
\newpage	
	
\tableofcontents
\newpage





\section{Úvod}
Ve své bakalářské práci se věnuji systémům, které pomocí měření z LIDARu (Light Detection And Ranging) utváří mapu prostředí, v němž se pohybují. V první části práce jsem se zaměřil obecně na problém simultánní lokalizace a mapování (SLAM). Mobilní robot je umístěn do neznámého prostředí a jeho úkolem je určovat svoji pozici a utvářet mapu. Zabývám se zde vnitřními principy a různými přístupy k řešení problému. Daná tématika momentálně vstupuje do podvědomí i širší veřejnosti, neboť pomalu dochází k přechodu na autonomní vozidla, která fungují na podobných principech. Tyto automobily však využívají i mnoho dalších senzorů, jako jsou například kamery. Já se zaměřuji na systémy využívající čistě jen 2D LIDAR, tedy sezor, měřící vzdálenosti pouze v jedné výškové úrovni.\\
\indent V další části své práce jsem se podrobněji věnoval třem nejrozšířenějším 2D SLAM systémům, přesněji se jedná o GMapping, HectorSLAM a Google Cartographer. Popsal jsem zde jejich základní rysy, kterými se liší od ostatních a jimiž je dostatečně charakterizována jejich funkčnost. \\
\indent měření, výsledky, porovnání, změna v gmappingu, proč jsem si vybral ...

\newpage

\section{Simultánní lokalizace a mapování}

V této sekci se nachází seznámení s problémem simultánní lokalizace a mapování. Procházím zde jak historii, tak strukturu algoritmů, na kterých jsou založeny jednotlivé systémy řešící problém SLAM. 

\subsection{Historie}
Za počátek diskuze problému se považuje konference Robotics and Automation Conference konaná v roce 1986. Pravděpodobnostní metody byly tehdy ještě velmi nerozvinuté, jak v robotice, tak i v umělé inteligenci. Došlo tedy pouze k debatě na dané téma.\\
\indent K většímu posunu kupředu se dostalo o pár let později, kdy vyšla práce pojednávající o vztahu mezi orientačními body (landmarky) a snížení geometrické nepřesnosti. Důležitým prvkem zde bylo zjištění, že mezi odhady landmarků na mapě je velká korelace, která je rostoucí s dalšími pozorováními.\\
\indent Ve stejném období vznikaly základy vizuální navigace a navigace pracující se sonarem s použitím Kalmanova filtru. Práce byly v základu podobné. Ukazovaly, že odhady landmarků získané pohybem robota prostředím, jsou v korelaci s ostatními kvůli chybě v odhadu pozice robota. Je tak třeba mít stav složený z pozice robota a landmarků, tím však vznikal velký stavový vektor s náročností rostoucí v kvadrátu. V daném období byla tendence korelaci landmarků snižovat.\\
\indent Později došlo k sjednocení problémů lokalizace a mapování a závěru, že snaha minimalizovat korelaci mezi landmarky byla chybná, naopak bylo v zájmu korelaci co nejvíce zvýšit. Struktura SLAMu, a celkově první použití tohoto akronymu, byla prezentována v roce 1995 na International Symposium of Robotics Research (ISRR). Poté se v roce 1999 na ISRR odehrálo první zasedání pojednávající přímo o SLAM a došlo k představení práce dosahující dostatečné konvergence mezi SLAMem využívající Kalmanův filtr a pravděpodobnostními metodami pro lokalizaci a mapování.


\subsection{Formulace a struktura} 
Jedná se o proces, při kterém robot vytváří mapu prostředí, v němž se pohybuje a na základě mapy určuje svoji pozici v prostoru. Pro určování trajektorie robota a rozložení landmarků není třeba předchozí znalosti jeho lokace, neboť odhad těchto parametrů probíhá v reálném čase. 

\subsubsection{Pravděpodobnostní SLAM}
Cílem je získat v časovém okamžiku k odhadu hustoty pravděpodobnosti
\begin{equation}
	P(\textbf{x}_k,\textbf{m}|\textbf{Z}_{0:k},\textbf{U}_{0:k},\textbf{x}_0)
\end{equation}
pro každý časový okamžik ${k}$, kde $\textbf{x}_k$ je stavový vektor popisující pozici a orientaci robota, $\textbf{m}$ je množina landmarů, tedy mapa, $\textbf{Z}_{0:k}$ jsou všechna pozorování landmarků, $\textbf{U}_{0:k}$ je historie vstupů a $\textbf{x}_0$ je počáteční stav. Jedná se tedy o srduženou posteriorní hustotu mapy, stavu vozidla s ohledem na zaznamenané pozorování, řídící vstupy a  počáteční stav robota. Pro výpočet je využit Bayesův teorém, který vyžaduje rozdělení algoritmu do dvou kroků. Prvním krokem je predikce, která využívá model pohybu robota. Tím druhým je korekce modelu pozorování, ke kterému jsou třeba data ze senzorů. Pohybový model a model pozorování tak popisují vliv vstupního řízení a pozorování.\\

\indent Model pozorování popisuje pravděpodobnost zisku pozorování $\textbf{z}_k$, pokud známe polohu vozidla $\textbf{x}_k$ a landmarků $\textbf{m}$.
\begin{equation}
	P(\textbf{z}_k|\textbf{x}_k,\textbf{m})
\end{equation} 
\indent Model pohybu vozidla může být popsán jako stavový přechodový model. \\Předpokládáme přechodový stav jako Markovův proces, při kterém následující stav $\textbf{x}_k$ je závislý pouze na předchozím stavu $\textbf{x}_{k-1}$ a aplikovaném řízení $\textbf{u}_k$ a není tak závislý ani na mapě, ani na pozorování.
\begin{equation}
	P(\textbf{x}_k|\textbf{x}_{k-1},\textbf{u}_k)
\end{equation}
Máme tak implementaci ve formě dvoukrokého rekurzivního algoritmu.\\
\\
Aktualizace času (predikce):
\begin{equation}
	\begin{split}
	P(\textbf{x}_k,\textbf{m}|\textbf{Z}&_{0:k-1},\textbf{U}_{0:k},\textbf{x}_0)=\\&\int P(\textbf{x}_k|\textbf{x}_{k-1},\textbf{u}_k)\times P(\textbf{x}_{k-1},\textbf{m}|\textbf{Z}_{0:k-1},\textbf{U}_{0:k-1},\textbf{x}_0)d\textbf{x}_{k-1}
	\end{split}
\end{equation}
\\
Aktualizace měření (korekce):
\begin{equation}
	P(\textbf{x}_k,\textbf{m}|\textbf{Z}_{0:k},\textbf{U}_{0:k},\textbf{x}_0)=\frac{P(\textbf{z}_k|\textbf{x}_k,\textbf{m})P(\textbf{x}_k,\textbf{m}|\textbf{Z}_{0:k-1},\textbf{U}_{0:k},\textbf{x}_0)}{P(\textbf{z}_k|\textbf{Z}_{0:k-1},\textbf{U}_{0:k})}
\end{equation}

\subsubsection{Struktura}
Model pozorování udává závislost polohy vozidla a pozice landmarků, z čehož vyplývá, že sdružená posteriorní pravděpodobnost nemůže být rozdělena na
\begin{equation}
	P(\textbf{x}_k,\textbf{m}|\textbf{z}_k)\neq P(\textbf{x}_k|\textbf{z}_k)P(\textbf{m}|\textbf{z}_k),
\end{equation}

neboť by to vedlo k chybným odhadům. Dalším zdrojem chyb je špatný odhad pozice robota. Landmarky jsou ale silně korelované, takže chybný odhad landmarku vůči mapě nevede k chybné poloze dvou landmarků navzájem.\\
\indent Velmi důležitým poznatkem bylo zjištění, že korelace mezi landmarky monotónně vzrůstá s počtem jejich pozorování (dokázáno pouze pro lineární Gaussovský případ + odkaz). Odhad pozice landmarku je tedy s narůstajícím počtem pozorování monotónně přesnější. Tento jev nastává díky, v podstatě, skoro nezávislému měření relativních pozic mezi landmarky. Ty jsou zcela nezávislé na natočení vozidla a úspěšné pozorovnání z tohoto bodu může nést další nezávislá měření relativních rozložení landmarků. \\
\indent Pohybem robota v prostoru, získává pozorováním novou pozici známých landmarků vůči sobě a dle této informace aktualizuje jejich pozici a též svoji odhadovanou polohu. Pokud již nějaký landmark není pozorován, tak je jeho pozice aktualizována dle změny pozorovaných landmarků. Při pozorování nových landmarků dochází ke korelaci s již známými, čímž se vytváří síť. Čím častěji jsou dva landmarky pozorovány při jednom měření, tím je síla korelace větší. Opětovným projížděním prostředím tak získáváme přesnější a robustnější mapu. Například násobným průchodem jedné smyčky se získá znatelně kvalitnější záznam o daném prostředí, než pouze jedním projetím.\\

\newpage
\subsection{Řešení problému SLAM}
Při řešení je potřeba adekvátně obsáhnout jak složku modelace prostředí, tak i tvorbu pohybového modelu.
Je řada možností jak tento problém řešit, například princip Monte Carlo, kdy se rozdělují hustoty pravděpodobnosti odhadu pozice robota. Další možností je Markovova lokalizace, jedná se o pravděpodobnostní formu SLAM. Nejčastější reprezentace problému ve formě stavového modelu zatíženého šumem, což vede k použití rozšířeného Kalmanova filtru (v originále $extended$ $Kalman$ $filter\rightarrow EKF$). Jinou možností je ještě rozčlenění pohybového modelu vozidla na vzorky s obecnějším negausovským rozdělením pravděpodobnosti. V tomto případě je řeč o použití Rao-Blackwellizovaného částicového filtru. 
\\
\subsection{EKF-SLAM}
EKF-SLAM je třída algoritmů využívající $extended$ $Kalman$ $filter$. Rozšířený Kalmanův filtr je implementací Bayesovské statistiky, která pracuje s gaussovským nelineárním systémem. \\
Pohyb robota je zde popsán rovnicí
\begin{equation}
	P(\textbf{x}_k|\textbf{x}_{k-1},\textbf{u}_k)\leftrightarrow \textbf{x}_k=\textbf{f}(\textbf{x}_{k-1},\textbf{u}_k)+\textbf{w}_k,
\end{equation} 
kde $\textbf{f}(\textbf{x}_{k-1},\textbf{u}_k)$ je funkce modelující pohyb robota a $\textbf{w}_k$ jsou chyby měření.\\
\\
Model pozorování je vyjádřen vztahem
\begin{equation}
	P(\textbf{z}_k|\textbf{x}_k,\textbf{m})\leftrightarrow \textbf{z}_k=\textbf{h}(\textbf{x}_k,\textbf{m})+\textbf{v}_k
\end{equation}
kde funkce $\textbf{g}(.)$ popisuje geometrické vlastnosti pozorování a $\textbf{v}_k$ jsou chyby měření.\\
\\
Tyto dvě definice jsou využity v metodě EKF k výpočtu průměru a kovariance sdruženého posteriorního rozložení\\
\indent průměr:
\begin{equation}
	\begin{bmatrix}
	\hat{\textbf{x}}_{k|k}\\\hat{\textbf{m}}_k
	\end{bmatrix}=E
	\begin{bmatrix}
	\textbf{x}_k |\textbf{Z}_{0:k}\\\textbf{m}\indent
	\end{bmatrix}
\end{equation}

\indent kovariance:
\begin{equation}
	\textbf{P}_{k|k}=\begin{bmatrix}
	\textbf{P}_{xx} \textbf{P}_{xm}\\\textbf{P}^T_{xm} \textbf{P}_{mm}
	\end{bmatrix}_{k|k}=E\begin{bmatrix}
	\begin{pmatrix}
	\textbf{x}_k-\hat{\textbf{x}}_k\\\textbf{m}-\hat{\textbf{m}}_k
	\end{pmatrix} \begin{pmatrix}
	\textbf{x}_k-\hat{\textbf{x}}_k\\\textbf{m}-\hat{\textbf{m}}_k
	\end{pmatrix}^T |\textbf{T}_{0:k}
	\end{bmatrix}
\end{equation}
Aktualizace času je pak počítána jako
\begin{equation}
\textbf{\^{x}}_{k|k-1}=\textbf{f}(\textbf{\^{x}}_{k-1|k-1},\textbf{u}_{k})
\end{equation}
\begin{equation}
	\textbf{P}_{xx,k|k-1}=\triangledown\textbf{f}\textbf{P}_{xx,k-1|k-1}\triangledown\textbf{f}^T+\textbf{Q}_k,
\end{equation}
kde $\triangledown\textbf{f}$ je Jacobián z funkce $\textbf{f}$, která vychází z odhadu stavu $\textbf{\^{x}}_{k-1|k-1}$.\\
\indent Aktualizace pozorování se provádí výpočtem rovnic
\begin{equation}
	\begin{bmatrix}
	\hat{\textbf{x}}_{k|k}\\\hat{\textbf{m}}_k
	\end{bmatrix}=
	[\textbf{\^{x}}_{k|k-1}\textbf{\^{m}}_{k-1}]+\textbf{W}_{k}[\textbf{z}_k-\textbf{h}(\textbf{\^{x}}_{k|k-1},\textbf{\^{m}}_{k-1})]
\end{equation}
\begin{equation}
	\textbf{P}_{k|k}=\textbf{P}_{k|k-1}-\textbf{W}_k\textbf{S}_k\textbf{W}^T_k,
\end{equation}
kde 
\begin{equation}
	\textbf{S}_k=\triangledown\textbf{h}\textbf{P}_{k|k-1}\triangledown\textbf{h}^T+\textbf{R}_k
\end{equation}
\begin{equation}
	\textbf{W}_k=\textbf{P}_{k|k-1}\triangledown\textbf{h}^T\textbf{S}^{-1}_k,
\end{equation}
přičemž $\triangledown\textbf{h}$ je Jacobián z funkce $\textbf{h}$, která vychází z odhadu stavu $\textbf{\^{x}}_{k|k-1}$ a odhadu mapy $\textbf{\^{m}}_{k-1}$.\\
\indent Mezi hlavní problémy této metody se řadí konvergence, výpočetní složitost, sdružování dat a nelinerita. Prvním z nich, konvergence, se projevuje postupným přechodem determinantu kovarianční matice mapy a všech podkategorií dvojic landmarků k nule. Jednotlivé odchylky landmarků pak konvergují dle původních nepřesností z odhadu pozice robota a jeho pozorování.\\
\indent Výpočetní složitost je kvadraticky rostoucí s počtem zaznamenaných landmarků, neboť při každém zaznamenaném pozorování se aktualizují již uložené landmarky. Tento problém prošel vývojem a existují metody pracující v reálném čase s tisíci landmarky.\\
\indent Metoda EKF-SLAM je velmi náchylná na chybné spojení pozorování se známými landmarky. Jedná se zejména o problém s uzavřením smyčky, kdy dochází k opětovnému návratu na místo, ze kterého robot začínal nebo ve kterém se již nacházel.\\
\indent Nelinerita je posledním z významných problémů. Kvůli ní může dojít k větším nepřesnostem ve výsledku, neboť EKF-SLAM využívá lineárních modelů pro vyjádření nelineárního pohybu a modelu pozorování. Konvergence a konzistence modelu je tedy jistá pouze v lineárním případě. 

\subsubsection{Výpočetní složitost}
Jedním ze základních kritérií všech algoritmů je jejich výpočetní složitost. Je tak třeba co nejvíce zjednodušit sdružený stav z pozice robota a landmarků a operace s nimi. Základním rozdělením metod redukujících výpočetní složitost, je rozlišování optimálních, konzervativních a nekonzistentních metod.\\ 
\indent První typ, optimální metody, jsou založené na redukci daného výpočtu. Rovnicí pro aktualizaci pozorování omezují požadované výpočty. Výsledkem jsou pak odhady a kovariance, stejně tak, jako je tomu v případě plnohodnotné formy SLAM. U metod konzervativních dochází k reformulaci stavového prostoru do informační podoby. To umožňuje rozdělení výsledné matice s informacemi, což vede ke snížení výpočtů, ale také k odhadům s vyšší neurčitostí nebo kovariancí. Konzervativní metody jsou nejčastěji implementovány v reálném použití, neboť dostatečně redukují výpočetní nároky a stále udržují dostatečnou odhadovací schopnost. Poslední možností jsou nekonzistentní metody. Jedná se o algorithmy, které mají nižší neurčitost nebo kovarianci, než algoritmy optimální. Pro řešení SLAM v praxi se ale nepoužívají.\\

\subsubsection{Oddělné aktualizace}
Metody využívající oddělěné aktualizce vytvářejí optimální odhady. Při implementaci základní podoby aktualizace pozorování, se při každém novém měření aktualizuje jak stav vozidla, tak i mapy. To vede ke kvadratickému nárůstu složitosti s množstvím landmarků. Při této implementaci se však mapa rozdělí na submapy.\\
\indent Rozlišují se dva způsoby možné implementace. První z nich pracuje na zmenšené oblasti, ale stále si drží globální referenční souřadnice, jedná se například o algoritmus $compressed$ $EKF$ (CEFK). Druhou možností je tvorba menších map s vlastním\\ souřadnicovým rámcem neopouštějícím danou submapu. Jsou to algorithmy $constrained$ $local$ $submap$ $filter$ (CLSF, v překladu - omezený lokální submapový filtr). Pro další rozbor je vhodnější druhá možnost, neboť je jednodušší a při provádění operací s velkou frekvencí opakování je méně ovlivněna linearizačními chybami. Je také stabilnější a zabraňuje příliš velkému nárůstu globální kovariance. \\
\indent Logaritmus submapy se skládá z dvou nezávislých odhadů, které si stále udržuje. Jde o vektory $x_G$ a $x_R$, kdy $x_G$ je mapa složená z globálně referencovaných landmarků a globálně referencované pozice dané submapy a $x_R$ je lokální submapa s lokálně referencovanou pozicí robota a lokálně referencovanými landmarky. Při získání pozorování se aktualizují pouze landmarky náležící aktuální submapě, ve které se robot nachází. Celkový globální odhad je pak získáván periodicky, zaevidováním submapy do mapy celé a použitím aktualizace omezení na společné vlatnosti obou map.

\subsubsection{Rozčlenění stavového prostoru}
V této metodě se vyjadřuje stavový odhad $\hat{x}_k$ a matice kovariance $P_k$ v informační formě pomocí matice informací $Y_k=P^{-1}_k$ a vektoru informací $\hat{y}_k=Y_k\hat{x}_k$. Pro mapy s větším měřítkem, kdy je spousta nediagonálních prvků velmi blízká nule, je vhodné nastavit tyto prvky na hodnotu nula. Může tím však vznikat malá ztráta optimality při vzniku map.\\
\indent Rozšíření stavu je rozčleňovací operace vedoucí k přesnému rozčlenění informační formy. Předpokladem je, že podmnožina stavů $x_i$ obsahuje většinu stavů mapy a po rozčlenění dosahuje pouze konstantní složitosti v čase. Je tedy možnost, získávat přesné řešení díky rozšiřování stavu novým odhadem pozice robota v každém kroce a zachovat všechny předchozí pozice. Nenulové nediagonální prvky jsou pouze ty, které jsou spojené napřímo s měřenými daty.\\
\indent Dalším důležitým pojmem je marginalizace, jež je nezbytná pro odstranění předchozích stavů pozice. Je možnost marginalizovat všechny předchozí stavy, což vede k zhuštěné matici informací. To je nežádoucí stav. Správnou volbou ukotvení pozice se může marginalizovat velká čast pozic, aniž by to vyvolalo nadměrnou hustotu matice informací.

\subsubsection{Asociace dat}
Jedná se o velmi důležitý problém, neboť, i když během procesu tvorby mapy dojde pouze k jedné chybné asociaci dat, může to vézt k destabilizaci odhadu mapy. Často dokonce k pádu celého algoritmu.\\
\indent Z prvu se k problému přistupovalo způsobem, kdy se každé jednotlivé zachycení landmarku porovnávalo se všemi odhady nacházejícími se v blízkém okolí. Tento individuální přístup je neproveditelný, pokud je nejistá pozice robota, tedy obvzláště v málo zaplněných prostředích. \\
\indent Při popisu vzhledu je vidění jedním z hlavních způsobů snímání okolí. Podle typu senzoru se zaznamenává například tvar, barva, struktura, a tím je možné rozlišovat různé balíčky dat. To je poté využito pro přepověd dané asociace, nejčastěji pro problém s uzavřením smyčky. Metoda přinesla pokrok, jelikož počítá metriku podobnosti přes sekvenci obrazů, místo původního jednoho.\\
\indent Multihypoziční asociace dat je metoda nepostradatelná pro robustní sběr dat v přeplněném prostředí, kdy se vytváří oddělené odhady trasy pohybu pro každou asociační hypotézu. Tato funkce je však silně limitována dotupným výpočetním výkonem.


\newpage
\subsection{Rao-Blackwellizovaný částicový filtr}
Forma SLAM na Rao-Blackwellizovaném filtru (RBPF), jinak nazývaná také jako FastSLAM, je založena na rekurzivním Monte Carlo modelu a dokáže reprezentovat nelineání stavový model. Dochází k odhadu celého posterioru, ne jenom nejpravděpodobnějšího sdružení dat, jedná se tedy o robustnější řešení než jakým je EKF. \\
\indent Částice zde znázorňují trasu robota, jedna částice je tedy vzorkem v cestě. Každá částice také obsahuje mapu, kde je každý landmark reprezentovaný vlastním Gaussiánem. Díky použití částicových filtrů se jedná o jedinou formu SLAM, která řeší jak problém $full$ $SLAM$, tak i problém $online$ $SLAM$. Odhadováním pozice robota v každém časovém okamžiku je algoritmus označován jako online. O odhad pozice se starají právě částicové filtry.\\
\indent Sdružený stav může být rozdělen zvlášť na komponentu robota a mapy. Posteriorní pravděpodobnost se tak dá odděleně počítat jako
\begin{equation}
	P(X_{0:k},m|Z_{0:k},U_{0:k},x_0)=P(m|X_{0:k},Z_{0:k})P(X_{0:k}|Z_{0:k},U_{0:k},x_0),
\end{equation}
kde $m$ je mapa, $X_{0:k}$ je trajektorie robota, $Z_{0:k}$ je sada všech již zpozorovaných landmarků, $U_{0:k}$ je historie řízení a $x_0$ úvodní pozice robota.\\
\indent Rozdělení pravděpodobnosti zde není na jednotivých pozicích $x_i$, ale na celou trajektorii $X_{0:k}$ a tím se stávají jednotlivé landmarky na sobě nezávislými, mapa je tedy reprezentována jako soubor nezávislých gaussiánů, což znamená lineární složitost oproti kvadratické u formy EKF. Hlavními ukazateli FastSLAMu je mapa, jež je počítána analyticky a vážené vzorky, jimiž je reprezentována trajektorie pohybu. Rekurzivní odhad je proveden částicovým filtrem pro stav pozice a EKF pro stav mapy.\\
\indent Zpracování každého landmarku probíhá zvlášť, pozice se aktualizuje stejným způsobem jako v EKF a landmarky, které nebyly zpozorovány, zůstávají na původní pozici a neaktualizují se. Vzájemnou neprovázaností landmarků však vzniká chyba v odhadu, která s časem roste.\\
\indent V čase $k-1$, je sdružený stav reprezentovaný jako 
\begin{equation}
	\{w^{(i)}_{k-1},X^{(i)}_{0:k-1},P(m|X^{(i)}_{0:k-1},Z_{0:k-1})\}^V_i,
\end{equation}
kde $w^{(i)}_{k}$ je váha vzorku $i$ v časovém okamžiku $k$. Sdružený stav v čase $k-1$ je poté použit v procesu generování nové sady částic. Sada znázorňuje potenciální cesty robota, ze které je poté na základě porovnání pozorování vybrána ta nejpravděpodobnější částice.\\
\indent V prvním kroce je pro každou částici vypočítáno návrhové rozložení, jež je podmíněno svojí specifickou historií. Z návrhu je odebrán vzorek $x_k$, který je poté sdružen k historii částice $X^{(i)}_{0:k}$. Krokem dva, dle funkce důležitosti, je stanovena váha vzorků:
\begin{equation}
	w_t^i=\frac{a}{b},
\end{equation}
kdy $a$ je cílové rozložení (rozložení, které je pro optimální pro sadu částic) a $b$ je návrhové rozložení. Třetím krokem je případné převzorkování, které se provádí různě často dle implementace. Krokem posledním je provedení EKF aktualizace pro každou již zpozorovanou částici, která je při aktuálním pozorováním zaznamenána. \\

\subsubsection{Asociace dat}
Funkcionalita systému popisovaná výše se vztahuje k datům, která mají známé sdružování. Pokud se jedná o data, pro která danou informaci nemáme, je třeba systém rozšířit. Problém sdružení dat spočívá v tom, že na bázi dostupných dat, není možno v časovém okamžiku $k$, určit proměnnou vyjadřující shodu $c_k$. Může se jednat například o neurčitost s pozicí, kdy má robot na základě pozorování možnost přiřadit více než jednu pozici.\\
\indent Běžně bývá na měření jedna asociace dat a tedy vzorkování pouze podél cesty. Zde ale dochází i k vzorkování nad možnými rozhodnutími v průběhu cesty. Chyby ve sdruženích tedy nejsou zdaleka tak fatální, jako je tomu například u EKF. Pokud dojde k převzorkování, chybně určené částice se díky tomu můžou jednoduše nahradit.

\newpage

\subsection{Graph-based SLAM}
Graph-based SLAM je algoritmus založený na metodě nejmenších čtverců. jedná se o offline algoritmus rozdělený do dvou částí, front-end a back-end.\\
\indent Metoda nejmenších čtverců je optimalizační metoda počítající s přeurčeným systémem, kdy je známo více rovnic, než je neznámých. Metodu představil na konci 18. století Carl Friedrich Gauss, a jak z názvu vyplývá, snaží se minimalizovat sumu chyb ve čtverci. Chyba je zde definována jako rozdíl odhadovaného stavu k aktuálnímu měření:
\begin{equation}
	\textbf{e}_i(x)=\textbf{z}_i-\textbf{f}_i(x)
\end{equation}  
Jedním z předpokladů pro správný průběh metody je dobrý počáteční odhad stavu. Dále, okolí minima chyby musí být hladké, bez skoků a zubů. V této oblasti se provádí lokální linearizace prvním stupněm Taylorova polynomu. Následně je vypočítána první derivace funkce chyby ve čtverci, která se položí rovna nule. Vyřeší se lineární systém, získá se nový stav, který by měl být lepší, než ten předchozí. Poté se znovu iteruje.
\subsubsection{Tvorba pozičního grafu}
Tvorba grafu je první částí metody Graph-based SLAM, tedy část vývojová (front-end). Dochází zde ke tvorbě pozičního grafu, který je zpracováván do mapy. Graf se složen ze dvou složek, a to z uzlů a hran. Uzel zde znázorňuje odhadovanou pozici robota a hrana omezení, které je mezi dvěma uzly. Toto spojení je nejisté a proměnné. Při projetí známým prostředím se vytvářejí hrany mezi uzlem novým a uzly již dříve zaznamenanými, což je využito například při uzavírání smyčky.\\
\indent Nové hrany vznikají při splnění jedné ze dvou podmínek. Pokud je zaznamenán přesun robota z pozice $x_i$ do $x_{i+1}$, hrana odpovídá naměřenné odometrii. Druhou možností je zpozorování stejného prostředí. Vzniká tak virtuální měření, ve kterém se porovnají obě tyto pozorování. Na základě rozdílu odhadované pozice při obou měřeních, se umístí nový uzel spojený odpovídající hranou. 
\subsubsection{Optimalizace mapy}
Druhou částí algoritmu Graph-based SLAM je back-end část, která zodpovídá za optimalizaci získaného grafu. Upravuje se zde pozice uzlů tak, aby byl získán stav, který co nejpřesněji vystihuje získaná měření. Po tomto procesu je pak možno utvořit mapu na základě známých pozic.\\
\indent Rovnice pro optimalizaci vychází z metody nejmenších čtverců:
\begin{equation}
	\textbf{x}^*=argmin_{\textbf{x}}\Sigma_{ij}\textbf{e}_{ij}^T(\textbf{x}_i,\textbf{x}_j)\Omega_{ij}\textbf{e}_{ij},
\end{equation}
kde $\textbf{x}^*$ je cílové rozmístění uzlů, chyba $\textbf{e}_{ij}$ vychází z (rovnice nahoře) a $\Omega_{ij}$ je informační matice pro danou hranu. 

\newpage
\subsection{Reprezentace prostředí}
Původně se svět modeloval jen jako soubor landmarků majících svůj určitý tvar, později však, zejména ve venkovním, podvodním a podzemním použití, se ukázala tato metoda jako nevyhovující. Hledaly se tak další metody, které by zlepšily reprezentaci prostředí. Výsledné možnosti jsou popsány v následujících odstavích.\\

\subsubsection{Mapa z landmarků}
V počátcích vývoje problému SLAM bylo pochopitelně potřeba vymyslet, jak reprezentovat výsledky měření a pozorování. Vznikla tedy metoda, kdy podobu mapy utvářely landmarky samotné. Když je nový landmark zpozorován, je zanesen do mapy a vytvoří se korelace k ostatním, již pozorovaným landmarkům. Odhadovaná pozice robota je také korelovaná vůči všem landmarkům. \\
\indent Opětovným projížděním známého místa korelace mezi landmarky roste a mapa se zpřesňuje. Tím, že jsou všechny landmarky ve vzájemné korelaci, vytváří se pomyslná síť z těchto spojení. Tato metoda může být při správné implementaci tedy velmi přesná. Problémem je však výpočetní náročnost, která kvadraticky roste s přibývajícími landmarky. Pro menší prostředí se tedy metoda využít dá, pro větší je to ale výkonově příliš náročné.

\subsubsection{Mřížkové mapy}
Metoda mřížkových map, v originále $Grid$ $maps$, byla představena v 80. letech minulého století. Její základní myšlenkou je diskretizace spojitého prostředí do jednotlivých buněk, přičemž mřížky rozdělující prostor na buňky mají pevnou velikost. Metoda je poměrně náročná na paměť.\\
\indent Důležitým faktorem je zde takzvaná obsazenost, v angličtině $occupancy$. V originále se tedy metoda nazývá $Occupancy$ $Grid$ $Maps$. Pravděpodobnost obsazení každé buňky může nabývat tří hodnot. Při inicializaci je hodnota pravděpodobnosti nastavena na $P(m_i)=0.5$, kdy $m_i$ je daná buňka. Tato počáteční hodnota znamená, že o buňce nemáme žádnou znalost. Poté, co se buňka dostane do dosahu senzoru, nabývá pravěpodobnost obsazenosti již pouze dvou hodnot. $P(m_i)=0$, pokud je buňka neobsazená a $P(m_i)=1$ v případě obsazenosti.\\
\indent Buňky jsou na sobě zcela nezávislé a součinem pravděpodobností obsazení buněk je získáno pravděpodobnostní rozložení mapy:
\begin{equation}
	p(m)=\Pi_ip(m_i)
\end{equation}
Odhad mapy ze senzoru:
\begin{equation}
	p(m|z_{1:t},x_{1:t})=\Pi_ip(m_i|z_{1:t},x_{1:t}),
\end{equation}
kdy $z_{1:t}$ jsou pozorování a $x_{1:t}$ pozice robota.

\subsubsection{Mračno bodů}
Výše zmíněné metody se vztahují především na práci s daty ve 2D. Pro zahrnutí třetí dimenze do mapy se tak využívají mračna bodů, v originálu $point$ $clouds$. Data se získávají například pomocí kamer, či 3D LIDARů. Výsledné mapy tak vytvářejí komplexnější reprezentaci prostředí, které se skládá z milionů až miliard bodů. Jednotlivé body nesou vždy informaci o své pozici v prostoru, při využití kamery i přímo odpovídající barvu. Barevné rozlišení se dá použít i jinými způsoby. Je možné mít škálu barev, ve které přechází barvy dle zaznamenané výšky. Případně mohou barvy znázorňovat míru pravděpodobnosti, že se daný bod opravdu nachází na odhadované pozici.

\newpage
\section{GMapping}
GMapping byl představen v roce 2007 v článku (Improved techinques...). Tato metoda je založená na implementaci Rao-Blackwellizovaného filtru, kde si každá vytvořená částice nese svoji mapu prostředí. Pro praktické využití je tedy nutné částicový filtr zefektivnit, což bylo úkolem tohoto systému. Jedna možnost je zahrnout přesnost měření do návrhového rozložení, tím je získáno přesné vykreslení částic. Druhou možností, je volba vzorkovací techniky udržující rozumný počet částic. Udržuje se tak přesná mapa a snižuje se riziko vyčerpání částice, což je problém vznikající při převzorkování.\\

\subsection{Mapování pomocí RBPF}
Základním úkolem je odhad posteriorní pravděpodobnosti a tím zisk mapy a trajektorie pohybu. Odhad je prováděn na základě porovnání pozorování a informaci z odometrie. Nejprve dochází k odhadu mapy, která je utvářena z porovnání pozorování, poté až trajektorie. Ta je získána z částic, které měly v rozhodovací době největší pravděpodobnost. Každá částice tedy reprezentuje část trajektorie.\\
\indent Pro výběr správné částice je použit částicový filtr, v tomto případěm Sampling Importance Resamplin (SIR), který při mapování postupně zpracovává data ze senzoru, poté odometrii a aktualizuje sadu vzorků reprezentující posteriorní pravděpodobnost, která zahrnuje informace o mapě a trajektorii. \\
\indent Nejprve se získají nové částice. To je provedeno odběrem vzorků z předchozí generace návrhového rozložení. V dalším kroce je částicím nastavena vážená důležitost, aby cílové rozložení nebylo rovno tomu navrhovanému. Poté dochází k převzorkování, kdy jsou částice přepisovány úměrně jejich váženým důležitostem. Nakonec se odhaduje podoba mapy, kdy je pro každou částici, na základě trajektorie vzorku a historie pozorování, mapa vypočítána.

\subsection{Vylepšené návrhy a adaptivní převzorkováním}
Pro zisk nové generace částic je třeba vykreslení vzorků z návrhového rozložení, kde platí úměra, čím lepší návrh, tím lepší výsledek. Kdyby byl návrh rovný cílovému rozložení, částice by měly stejnou váženou důležitost a převzorkování by nebylo třeba. \\
\indent Návrhové rozložení typicky odpovídá odometrickému pohybovému modelu, který však není optimální a to zejména, pokud je senzor výrazně přesnější než odhad pozice. Využívá se také vyhlazování pravděpodobnostní funkce, což zabraňuje částicím v okolí významné oblasti, aby vážené důležitosti příliš poklesly. Následkem je ale zkreslení mapy. To se však dá vyřešit zahrnutím posledního pozorování do generování nových vzorků. Díky tomu se systém zaměřuje na vzorkování ve významné oblasti pravděpodobnosti pozorování.\\
\indent Zlepšením návrhu se objevuje možnost získávat pro každou částici zvlášť její parametry Gaussiánského návrhu a snižuje se také neurčitost výsledných hustot pravěpodobností. Porovnávač pozorování má funkci maximalizace pravděpodobnosti pozorování, tvorby mapy a počáteční odhad pozice robota. Pokud je pravděpodobnostní funkce vícerežimová, například při uzavírání smyčky, porovnávač vrací pro každou částici nejbližší lokální maximum.To může způsobit vynechání některých maxim v pavděpodobnostní funkci.\\
\indent Převzorkování je velice důležitým aspektem určujícím výkon částicového filtru. Dochází k nahrazování vzorků s nízkou váhou. Je to nezbytný proces, neboť je potřeba konečného počtu částic pro aproximaci cílového rozložení. Může však odstranit dobré vzorky a ochudit tak částice, je proto důležité mít pro převzorkování vhodné rozhodovací kritérium a provádět ho ve správný čas. 
\begin{equation}
	N_{eff}=\frac{1}{\varSigma_{i-1}^N(w^{(i)})^2},
\end{equation} 
$w^{(i)}$ je zde normalizovaná váha částice $i$ a $N_{eff}$ jsou vzorky z cílového rozložení, které mají stejné váhové důležitosti. Pokud dochází ke zhoršení aproximace cílového rozložení, nastává větší odchylka vážených důležitostí.\\
Základní nastavení převzorkování je následující:
\begin{equation}
	N_{eff} < N/2,
\end{equation}
kde $N$ je počet částic. Tím dochází k výrazné redukci možnosti nahrazení dobrých částic a počtu převzorkování, které se vykonává pouze pokud je třeba.\\
\indent Algoritmus probíhá následovně. Dojde k zisku odhadu pozice, který je reprezentovaný danou částicí. Odhad je získán z předchozí pozice částice a odometrického měření od poslední aktualizace. Na základě mapy je provedeno porovnání pozorování z místa úvodního odhadu pozice, kdy se vyhledává pouze v okolí tohoto bodu. V případě selhání se pozice a váhy počítají dle pohybového modelu a následující dva kroky jsou přeskočeny. Prvním z nich je vybrání sady vzorků v okolí dané pozice, vypočítání průměrů a kovarianční matice návrhu pomocí bodového ohodnocení cílového rozložení v pozici vzorku. Druhým, potenciálně přeskočeným krokem, je zakreslení nové pozice částice z Gaussovské aproximace podle zlepšeného návrhového rozložení. Dále, a to již vždy, dojde k aktualizaci vážených důležitostí a, podle zakreslené pozice a pozorování, je aktualizována i mapa částice. 
 
\newpage

\section{Hector SLAM}

Hector SLAM je systém představený v roce 2011 v práci (A Flexible and scalable). Jeho hlavním znakem je rychlost a nízké výpočetní nároky oproti předchozím dvěma typům, které jsou v této práci rozebírány. Je tedy vhodný pro implementaci v menších autonomních systémech, pro rychlý pohyb terénem a nehodí se pro uzavírání velkých smyček.\\
\indent Vnitřní skladba systému je ze tří hlavních částí, a to 2D SLAM, běžící jako soft real time, 3D navigace, která je hard real time a inerciální jednotka (IMU). Hector SLAM je braný jako front-end SLAM, což znamená, že dochází k odhadu stavu robota v reálném čase a nedochází ke zpětné optimalizaci mapy.\\
\indent Daný systém se musí převézt z 3DOF přidáním naklonění a rotace na 6DOF, kdy navigační filtr spojí měření z IMU a dalších senzorů. Tím dojde k získání 3D řešení. 2D SLAM poté poskytuje informaci o poloze v prostoru. Oba odhady se aktualizují nezávisle na sobě a jsou propojeny jen velmi málo.\\
\indent Kvůli znatelnému posunu odhadů integrované pozice a rychlosti, který je způsoben šumem v senzorech, jsou do systému zahrnuty další informace. Jedná se například o porovnávání snímků, snímání magnetického pole, senzor barometrického tlaku a nebo měření rychlosti kol.

Pohyb robota je popsán:
\begin{equation}
	\dot{\Omega}=E_\Omega.\omega
\end{equation}
\begin{equation}
	\dot{p}=v\\
\end{equation}
\begin{equation}
	\dot{v}=R_\Omega.a+g,
\end{equation}\\
kde $\Omega=(\phi,\theta,\psi)^T$ je informace o otáčení, stoupání a natočení. Vektor $x=(\Omega^T p^T v^T)^T$ reprezentuje 3D stav, $p,v$ jsou pozice a rychlost platformy v navigačním rámci. Vektor $u=(\omega^T a^T)^T$ je vstupní vektor pro inerciální měření, $\omega=(\omega_x,\omega_y,\omega_z)^T$ je úhlová rychlost a $a=(a_x,a_y,a_z)^T$ je zrychlení. $R_\Omega$ je pak matice směrových cosinů, $E_\Omega$ je mapování natočení těla na deriváty Eulerova úhlu a $g$ je vektor gravitace.\\

\subsection{2D SLAM}
Jako reprezentace prostředí je zde vybrána metoda mřížkových map. Odhadovaná pozice robota slouží pro transformaci pozorování na lokální souřadnicový rámec. Odhadovanou orientací a přidruženými hodnotami je z pozorování vytvořen oblak bodů, který je předzpracován pro odstranění odlehlých bodů. Filtrace probíhá pouze na základě souřadnic koncového bodu, kdy jsou pro porovnávání pozorování použity pouze koncové body v rámci skenovací roviny.\\
\indent Jak již bylo poznamenáno, je zde použita struktura mřížkových map, to vede k omezení přesnosti a neumožnění přímého výpočtu interpolovaných hodnot a derivátů. Pro oba odhady se tedy využívá interpolační schéma, díky kterému tato možnost je. Souřadnice, které se potřebují nahradit, se aproximují pomocí čtyř nejbližších integerových souřadnic. \\
\indent Laserové skenery jsou již velice přesná zařízení, jejich měření zatěžuje minimální šum a snímky se dají vytvářet s vysokou frekvencí. Měření pomocí laseru je tedy mnohem přesnější než to odometrické, což je jeden z důvodu, proč je odometrie v tomto systému zcela vynechána. Při zarovnávání snímků s již známou mapou není potřeba hledat žádná spojení mezi koncovými body, ale dochází k porovnávání s předchozími skeny.  

Hledání transformace pro nejlepší sladění skenu s mapou:
\begin{equation}
	\xi^*=argmin_\xi\Sigma_{i=1}^n[1-M(S_i(\xi))]^2
\end{equation}
$M(P_m)$ je zde hodnota obsazenosti a $S_i(\xi)$ jsou souřadnice koncového bodu $s_i=(s_{i,x},s_{i,y})^T$, přičemž $\xi$ jsou souřadnice robota.\\
 
Optimalizace chyby měření: 
\begin{equation}
	\Sigma_{i=1}^n[1-M(S_i(\xi+\Delta\xi))]^2\rightarrow 0,
\end{equation}
kde $\Delta\xi$ je odhad $\xi$.\\
\indent Při tvorbě mapy dochází často k nalezení pouze lokálního minima, reprezentací mapy pomocí více rozlišení se tak toto riziko znatelně redukuje. Utváří se mřížkové mapy, kdy každá další má poloviční rozlišení, než ta předchozí. Je tak uloženo více map, které se součastně aktualizují podle odhadu aktuální pozice. Díky tomuto přístupu jsou mapy konzistentní a nepotřebují převzorkování. Zarovnávání pozorování probíhá pouze na mapě s nejvyšším rozlišením a tento odhad je pak použit pro ostatní mapy. Mapy s nízkým rozlišením jsou tedy v podstatě dostupné okamžitě, a lze je hned využít pro odhad trasy. 

\subsection{Odhad 3D stavu}
Pro odhad úplného 6D stavu (3D stav + informace o naklonění z gyroskopů a informace z akcelerometrů) slouží navigační filtr běžící v reálném čase. Filtr je asynchronně aktualizován při příchodu odhadované pozice z porovnávače pozorování nebo jiných informací ze senzorů. Filtr je implementován ve formě EKF, jedná se tedy o nelineární filtr a jako jeho známé vstupy se berou inerciální měření. Rychlost a pozice je získávána integrací zrychlení. Aby se ale zabránilo nezávislému růstu odhadu stavu při nepřítomnosti měření, dochází k aktualizaci pseudo-nulové rychlosti, která se spouští při dosažení odchylky určité prahové hodnoty a zajišťuje tak stabilitu systému.\\

\newpage

\section{Catographer}

Systém Cartographer je vyvíjen společností Google a aktuální verze byla publikována v roce 2012 (Real-Time Loop Closure...).Jedná se o implementaci Graph-Based SLAM. Je vhodný pro tvorbu rozsáhlých map a zisk optimalizovaných výsledků v reálném čase. \\
\indent Cartographer vytváří v reálném čase 2D mřížkovou mapu. Submapy se vkládají na odhadované místo a daná submapa se porovnává vůči poslední zaznamenané. Dochází tedy k hromadění globální chyby z odhadu pozice. Systém neobsahuje žádný částicový filtr a to z důvodu snížení hardwarových nároků na běh algoritmu.\\
\indent Submapa se po pořízení již dále nijak nepřepisuje a je zařazena mezi ostatní k porovnávání na uzavření smyčky. Pokud dojde k blízkému odhadu pozice a zároveň dostatečné shodě snímků, přidá se omezení uzavření smyčky do optimalizačního problému, čímž je odhad pozice. Odhad se aktualizuje po několika vteřinách a uzavření smyčky je tedy okamžitě viditelné.\\
\indent Rozlišují se dva možné přístupy, lokální a globální, v obou případech se jedná o optimalizaci pozice, přičemž pozice se zkládá z hodnoty na ose $x$, z hodnoty na ose $y$ a z natočení robota. V systému je také obsažená jednotka IMU, která slouží k odhadu směru gravitace, což má využití při pohybu na nerovné ploše.\\

\subsection{Lokální 2D SLAM}
\indent Skeny prostředí se iterativně zarovnávají se snímky již obsaženými v submapě. Submapa je tedy v postatě zachycení kousku světa, který je složený z pár skenů. Lokální chyba, vznikající při její tvorbě, je poté odstraněna v globálním přístupu. Pro každý bod mřížky je definován odpovídající pixel skládající se ze všech pixelů nejblíže danému bodu.\\
\indent Při přidání skenu do pravděpodobnostní mřížky je počítána množina zasažených bodů mřížky a bodů minutých. Při zásahu se nejbližší bod mřížky vloží do množiny zásahů. Při nezaznamenání překážky jsou vloženy do množiny minutí všechny body odpovídající dráze laserového paprsku. Dosud nepozorované body mřížky mají přiřazenou pravděpodobnost minutí či zásahu, podle toho, jestli se v jedné z těchto množin vyskytují. Již pozorovaným bodům se pak aktualizují pravděpodobnosti minutí a zásahu.\\
\indent Před vložením skenu do submapy se ještě využívá Ceres scan matching, který optimalizuje pozici skenu vůči submapě. Jedná se o maximalizaci pravděpodobnosti výskytu v dané oblasti.  

\begin{equation}
argmin_\xi\Sigma^K_{k=1}(1-M(T_{\xi}h_k))
\end{equation}

$H$ je zde informace o bodech skenu, $M$ je pravděpodobnostní mřížka, $\xi$ je pozice snímání skenu a $T_{\xi}$ je pozice skenu vůči submapě. Dochází k transormaci, kdy body skenu se transformují do submapy.

\subsection{Globální 2D SLAM}
Daný systém pracuje v oblasti submap s porovnáváním scan-to-scan, hromadí se v něm tedy lokální chyby. Pár snímků za sebou má však vůči sobě chybu minimální. Relativní pozice skenů se ukládají a v případě, že se submapa nezmění, všechny další páry ze skenů a submapy se předkládají k porovnávání pro uzavření smyčky. To vše běží na pozadí a pokud je nalezena shoda, dojde k uložení relativní pozice mezi optimalizační problémy.\\
\indent Optimalizační problém je problém nelineárních nejmenších čtverců. Díky tomu je můžou jednoduše přidávat zbytky pro zohledňování dalších dat. Jednou za pár sekund je, pro optimalizaci pozice skenu vůči daným omezením, spuštěn Ceres scan matching. Omezeními jsou myšlena relativní pozice $\xi_{ij}$ a kovarianční matice $\Sigma_{ij}$.
\begin{equation}
argmin_{\Xi^m,\Xi^s}\frac{1}{2}\Sigma_{ij}\rho(E^2(\xi_i^m,\xi_j^s,\Sigma_{ij},\xi_{ij})),
\end{equation}\\
kde $\rho$ je ztrátová funkce, například tedy Hubertova ztráta. Jedná se o snížení vlivu odlehlých hodnot, které přidávají nesprávná omezení do optimalizačního problému.\\
\indent Při uzavírání smyčky se vyžívá také branch-and-bound scan matching, což se dá přeložit jako porovnávání větví a mezí. Zde se metoda zaměřuje na přesnou shodu pixelů. Podmnožiny možností jsou popsány jako uzly stromu, kdy kořenový uzel obsahuje všechna možné možnosti $W$. Potomci uzlu dohromady utváří stejný soubor možností, jako samotný rodičovský uzel. Listy jsou brány jako singlety, odpovídají jedinému proveditelnému řešení. Tento přístup dává stejné řešení jako ten předchozí, dokud je hodnota $score(c)$ vnitřních uzlů horní mezní skóre jeho prvků. Neexistuje tedy žádné řešení, než to doposud známé.

\begin{equation}
\xi^*=argmax_{(\xi\epsilon W)}\Sigma_{k=1}^KM_{nearest}(T_{\xi}h_k)
\end{equation}\\
$W$ je zde vyhledávací okno a $M_{nearest}$ je rozšíření pravděpodobnostní mřížky $M$ na všechny $R^2$ zaokrouhlením argumentů do nejbližšího bodu mřížky. Rozšířená hodnota bodu mřížky ukazuje na odpovídající pixel.\\
\indent Výběr uzlů probíhá prohledáváním do hloubky. Efektivnost algoritmu hodně závisí na podobě stromu, zda-li má pro výpočet dobrou horní mez a dobré aktuální řešení. Důležitým termínem je zde prahová hodnota skóre. Jedná se o hodnotu, pod níž není v zájmu jít a řešení je tedy nevyhovující. Díky tomu se nepřidávají špatné shody jako omezení pro uzavírání smyčky. Pro rychlost algoritmu je důležité rozhodování o průchodu stromem. Pro každého potomka je vypočítána horní hranice skóre a je vybrán ten nejslibnější, což je uzel s největším mezním počtem.\\
\indent Každý z uzlů je popsán pomocí pole integerů: 
\begin{equation}
c=(c_x,c_y,c_\Theta,c_h)\epsilon Z^4,
\end{equation}\\
kde $c_h$ je výška uzlu. Pokud $c_h=0$, uzel je list.\\
\indent Horní meze jsou pak počítány přes vnitřní uzly: 
\begin{equation}
score(c)=\Sigma_{k=1}^Kmax_{(j\epsilon \bar{W})}M_{nearest}(T_{\xi_j}h_k)
\end{equation}

\newpage




\section{Experimentální měření}
Pro testování všech výše zmíněných systémů jsem využil framework $Robot$ $Operating$ $System$ (ROS). V této části práce je tedy popsána jeho funkčnost a využití. Dále je zde porovnání implementací SLAM, jak na simulačních datech, tak i na datech reálných. Porovnání je provedeno výpočtem chyb v trajektoriích jízdy a v případě nekonvergence systému rozebráním situace, proč k danému problému došlo.

\subsection{Robot Operating System}
Robot operating system, zkráceně ROS, je operační systém určený pro ovládání robotů. Poskytuje vše očekávané od operačního systému, jako je například abstrakce hardwaru, nízkoúrovňové ovládání, komunikace mezi procesy a mnoho dalších funkcí. Obsahuje také nástroje a knihovny pro vytváření, získávání, psaní a spouštění kódu na více zařízeních. ROS prozatím běží pouze na platformách založených na Unixu. Software je testovaný především na systémech s Ubuntu nebo Mac OS X, přičemž s Windows není zatím kompatibilní.\\
\indent Při běhu je komunikační infrastrukturou ROSu vytvářena síť volně propojených procesů, které mohou běžet na více zařízeních. Implementováno je zde několik možných komunikačních stylů. Přes služby je to synchronní komunikace RPC ($Remote$ $Procedure$ $Call$ = vzdálené volání procedur). Je to jedna z nejstarších metod pro komunikaci programů na dálku. Obsahuje mechanismus umožňující volat z programu funkce ze vzdáleného počítače. Dalším obsaženým stylem komunikace je asynchronní streamování dat, které běží přes topiky. Posledním je ukládání dat na $Parameter$ $Server$, což je sdílený víceúrovňový slovník, který je přístupný prostřednictvím síťových rozhranní API. Procesy, označované jako $nodes$, využívají tento server k ukládání a načítání dat za běhu.\\
\indent Existuje celá řada softwarových platforem pro roboty a je těžké porovnávat, která z nich je ta nejlepší. ROS je open source systém, hlavní jeho snahou je znovuvyužitelnost napsaného kódu a multiplatformní provozuschopnost, což z něj činí nejrozšířenější systém pro roboty. Celý rámec je složený z distribuovaných procesů, nodů. $Nodes$ jsou individuáně spustitelné soubory, které se ze běhu volně propojují do peer-to-peer sítě, mohou být seskupeny do balíků a být tak jednoduše sdíleny.\\
\indent Jednou z dalších snah systému ROS je co největší hubenost. Nedochází k zabalení metody main() a tím může být kód využit i jinými frameworky. ROS je tak snadné integrovat s dalšími robotickými softwarovými frameworky, jako je například OpenRAVE nebo OROCOS. Dalším důležitým rysem je jazyková nezávislost, kdy je možné plně využívat jazyků Python, C++ a Lisp. Dále, zatím experimentálně, je možné používat určité knihovny z jazyků Java a Lua. Neméně důležitými vlatnostmi jsou také škálovatelnost, což je pro velké runtime systémy vlastnost velmi užitečná a snadné testování pomocí vestavěné jednotky $rostest$.\\
\indent Ros se skládá ze tří úrovní pojmů. První úrovní je souborový systém, další je výpočetní graf a poslední je komunitní úroveň.\\

\subsubsection{Souborový systém}
Na úrovni souborového systému jsou v ROSu myšleny všechny prostředky, se kterými se pracuje na pevném disku. Jedná se o balíčky ($Pakages$), $Metapackages$, $Package$ $Manifests$, repozitáře, typy zpráv a typy služeb.\\
\indent Balíčky jsou základní stavební jednotkou softwaru ROS. Jedná se o nejnižší strukturu umožňující tvorbu programu. Balíčky mohou obsahovat $ROS$ $runtime$ procesy, dále knihovny závislé na ROSu, datové sady, konfigurační soubory a mnoho dalšího, co lze užitečně zahrnout do jednoho souboru.\\
\indent $Metapackage$ se již nachází výše, je to specializovaný balíček, který slouží k reprezentaci skupiny souvisejících balíčků. Nejčastější jejich využití je držení zpětné kompatibility pro zásobníky ($Stacks$), které prošly konverzí přes $rosbuild$. $Stacks$ jsou též kolekce balíčků, které seskupují určité funkce, například $navigation$ $stack$, jenž na základě informací ze senzorů dává příkazy pro další navigaci robota v prostředí. $Package$ $Manifest$, package.xml, poskytuje metadata o daném balíčku. Jsou v něm obsažené informace jako název, verze, popis, licenční informace, závislosti a další.\\
\indent Repozitář je opět souhrn balíčků (může však obsahovat pouze jeden balíček), které sdílejí společný VCS ($Version$ $Controlling$ $System$), což je systém sdílející stejnou verzi. Balíčky tak mohou být společně uvolněny užitím nástoje $catkin$. Repozitáře často mapují převedené $Stacks$ přes $rosbuild$.\\
\indent Typy zpráv a typy služeb pak již definují typy, které se smějí v ROS využívat. Pro typy zpráv je cesta k souboru $my\_package/msg/MyMessageType.msg$ a obsahuje datvé struktury pro posílané zprávy. Definice typů služeb se nachází na adrese $my\_package/srv/MyServiceType.srv$ a definuje datové struktury požadavků a odpovědí.\\

\subsubsection{Výpočetní graf}
Výpočetní graf se skládá z jednotlivých procesů zpracovávajících společně sdílená data a dohromady vytvářejících peer-to-peer síť. Základními pojmy pro výpočetní graf jsou $nodes$, $Master$, $Parameter$ $Server$, zprávy, topiky, služby a bagy. Všechny pojmy jsou implementovány v repozitáři pro komunikaci $ros\_comm$.\\
\indent $Nodes$, v překladu uzly, jsou procesy obstarávající výpočty. Řídicí systémy pro robota obsahují často mnoho uzlů. Pro ROS je typická snaha o co největší modularitu, každý $node$ má tak jednu svoji úlohu, například zpracování laserového senzoru. $Nodes$ jsou nejčastěji psány pomocí knihoven $roscpp$ nebo $rospy$, kde písmena za $ros$ znamenají, zda-li se jedná o implementaci jazyka C++ nebo Python.\\
\indent $Master$ zde zajišťuje registraci jmen a vyhledávání ve výpočetním grafu. Uzly s $Masterem$ komunikují a oznamují mu své registrační údaje, bez něj by se tedy uzly navzájem nemohly najít a vyměňovat si zprávy. Při změně registračních údajů provede $Master$ zpětné volání uzlů, tím je zajištěno dynamické vytváření spojení mezi uzly. Blízce související termín je $Parameter$ $Server$, který je součástí $Mastera$ a umožňuje ukládání dat do centrálního umístění.\\
\indent Zprávy jsou informace posílané mezi $nodes$. Jsou tvořeny datovými typy jako je integer, float, boolean a tak dále a nebo ve formě pole obsahujících tyto primitivní typy.\\
\indent Topik je název sloužící k identifikaci obsahu, kterým je určitá zpráva. Pokud chce $node$ určitý typ dat, začne odeírat data z příslušného topiku. Pokud chce uzel data do topiku odesílat, publikuje do něj danou zprávu. Do jednoho topiku může zapisovat i číst z něj zároveň více uzlů a jeden $node$ může odebírat a publikovat do více topiků. $Nodes$, ať publikující, či odebírající, nejsou si vědomy ostatních účastníků u daného topiku.\\
\indent Komunikační model typu publikující/odběratel je vhodný pro posílání zpráv. Pro distribuované systémy, které využívají interakce typu žádost/odpověď, je to však nevyhovující. Tato interakce se tedy provádí pomocí služeb, které jsou definovány dvojicí struktur. Jedna pro žádost a druhá pro odpověď. Například $node$ nabízí určitou službu pod jménem a klient tétu služby využívá zasláním požadavku, kdy poté čeká na odpověď.\\
\indent Posledním pojmem jsou zde bagy, v originálu $Bags$, které slouží k uložení a přehrávání dat z topiků. Jedná se o důležitý mechanismus skladování dat, který je nezbytný pro vývoj a testování algoritmů.\\
\indent Pro ROS jsou velmi důležitá pojmenování. Jména jsou primárním prostředkem pro vybudování velkého a složitého systému. Každy uzel, topik, služba nebo parametr má svůj název. Všechny klientské knihovny podporují přemapování názvu z příkazového řádku, běžící programy tak mohou být za běhu překonfigurovány, aby fungovaly i odlišné topologii výpočetního grafu.\\

\subsubsection{Komunitní úroveň}
Jedná se o zdroje, které umožňují různým skupinám vývojářů, vyměňovat si software a znalosti. Spadají sem distribuce, což jsou kolekce verzovaných stacků, které lze nainstalovat. Mají dost podobnou úlohu jako distribuce Linuxu, usnadňují tedy instalaci kolekce softwaru a následné udržování konzistentní verze. Dále sem patří repozitáře, kdy různé instituce mohou vyvíjet své vlastní softwarové komponenty robota a sdílet je tak pomocí federované sítě úložišť. Velmi důležitým zdrojem je $The$ $ROS$ $Wiki$, což je hlavní fórum pro dokumentaci informací o ROSu. Kdokoliv přihlášený na svůj účet tak může přidávat nové, či upravovat a aktualizovat již vzniklé dokumentace, psát návody a mnoho dalších věcí užitečných pro komunitu.

\newpage

\subsection{Zisk dat k porovnání}
Data potřebná pro porovnávání se dají získat prostřdednictvím internetu. Existují veřejně přístupné nahrané datasety z MIT, Deutsche Museum a řady dalších míst. Pro vyzkoušení systémů na velkých datech jsem tedy danou možnost také využil. Pro porovnání implementací jsem ale převážně používal své datasety získané jak ze simulace v ROS, tak i reálná data naměřená robotem $Dagu$ $Wild$ $Thumper$ $6WD$. Získání datasetu je pro porovnání implementací zásadním faktorem. Systémy SLAM mohou samozřejmě jednotlivě běžet na aktuálně simulovaných datech, pro porovnání jsou však potřebná data stejná.\\ 
\indent Datasety jsou v ROS ukládány ve formátu $bag$, kde se jsou nahrány vybrané topiky. Pro každou porovnávanou implementaci jsem vytvořil $launch$ soubory, které při zavolání spouštějí uvedené $nodes$ se specifikovaným nastavením. Soubory $launch$ jsem pro všechny systémy nastavil tak, aby potřebovali informaci o měření z LIDARu, odometrickou informaci a transformaci přepočítávající pozici robota. Tyto tři typy informací stačí při spuštění dané metody k vytvoření mapy a všeho k tomu přidruženého. Pro porovnání trajektorií je potřeba uložit ještě informaci o přesné pozici robota, neboli $ground$ $truth$. V mnou nahraných souborech $bag$ se tedy nachází pouze tyto zmíněné čtyři informace. Výjimkou jsou data získaná robotem $Wild$ $Thumper$. $Ground$ $truth$ by zde měla vycházet z odometrie kol, tudíž o informaci méně. Odometrie z kol robota je však natolik nepřesná, že se pro účely porovnávání nedá využít. Tato nepřesnost samozřejmě zhoršuje provedení metod, které odometrii využívají (Cartographer, gMapping), podrobnější popis dané problematiky se nachází u vyhodnocení daného typu naměřených dat.

\subsubsection{Simulace v ROS}
Pro zisk dat pomocí simulace jsou v systému ROS implementovány dva hlavní simulátory. Prvním z nich je $Gazebo$. Jedná se o nástroj určený pro simulaci ve 3D, stále prochází vývojem a je nejpoužívanějším simulátorem v ROS. Pro mé účely má však zbytečně veliké množství nastavení. Zvolil jsem tedy nástroj $Stage$, který je starší, má méně funkcí, má ale také menší výkonostní nároky a pro simulaci robota s 2D LIDARem je naprosto vyhovující.\\
\indent Své simulační prostředí jsem rozložil do tří souborů. Dva s příponou $inc$, kdy první obsahuje informace pro načtení mapy. Jsou zde obsaženy informace o velikosti, frekvenci obnovování, výšku překážek v ose $z$ a různá boolean nastavení. V druhém $inc$ souboru se pak nachází informace o simulačním robotovi. Zvolil jsem trojúhleníkovou platformu, na které se nachází malý čtvercový blok simulující LIDAR. Je zde osaženo i jeho nastavení, jako je počet paprsků, úhel rozsahu a vzdálenost dosahu. Posledním konfiguračním souborem je soubor $wolrd$, ve kterém se nachází nastavení velikosti okna a načtení obou souborů $.inc$. Při načítání souboru s nastevením mapy je zde definován obrázek obsahující mapu a s načítáním souboru o robotovi se definuje jeho pozice v prostoru.\\
\indent Pro nahrání dat poté stačí příkazem
\begin{center}
	\texttt{rosrun stage\_ros stageros file.world}
\end{center}
spustit simulaci a pomocí některého z navigačních balíčků s robotem v mapě jezdit. Osobně jsem si zvolil knihovnu $teleop\_twist\_keyboard$, která umožňuje navigaci robota pomocí klávesnice.

\subsubsection{Nahrání reálných dat}
K nahrání reálného datasetu jsem měl k dispozici robota $Wild$ $Thumper$ $6WD$. Jedná se o robota s pohonem šesti kol. Hliníkové tělo má v sobě s rozestupem jednoho centimetru díry, díky kterým se na něj dají jednoduše přidělat další součástky. \\
\indent Pro řízení kol je využito Arduino, pro zpracování dat a komunikaci je zde superpočítač od společnosti NVIDIA, jehož označení je Jetson TX2 a velikost 50 x 87 milimetrů. Výpočetní výkon zajišťuje osmijádrový procesor s architekturou jádra ARMv8. Velikost operační paměti má 8 GB a úložiště 32 GB. Pro komunikaci je zde rozhraní Wi-Fi 802.11ac a Bluetooth 4.1. Jako měřící senzor je zde využit LIDAR $Hokuyo$ $URG-04LX-UG01$ s detekovatelným rozsahem od dvou centimetrů do 5,6 metru. Daný sezor má rozsah snímání 240$^o$ s úhlovým rozlišením 0,36$^o$. Obnovovací frekvence je 100 milisekund a uvedená přesnost je 30 milimetrů.\\
\indent Pro pohyb robota v prostoru jsem využil možnost připojení bezdrátového ovladače $Xbox$ $One$ $Wireless$ $Controller$. Přesto, že robot díky integrovanému počítači od NVIDIA má velmi vysoký výkon, tyto prostředky jsem nevyužil a data při běhu programu posílal rovnou do počítače, kde jsem je ukládal do souboru $bag$. Ke spojení byl využit Wi-Fi router $Ubiquiti$ $AirCube$ $AC$, který musí být připojen ethernetovým kabelem k danému počítači. Tento druh propojení má své jisté výhody i nevýhody. Výhodou je bezproblémový přenos, který při připojení robota rovnou na univerzitní Wi-Fi nebyl zdaleka pravidlem. Nevýhodou tohoto řešení je dosah, který je limitován, stejně tak jako je tomu běžně u vysílačů Wi-Fi signálu. Pro mé účely to však nakonec nebyl problém a vhodným umístěním routeru se mi podařilo naměřit data na dostatečném prostoru. 

\subsubsection{Uložení trajektorie}
Po nahrání datasetu a spuštěním všech metod SLAM na těchto datech, je získána množina výsledků, kterou je možno porovnat. Je více možností jak implementace porovnávat, kromě trajektorie je možné srovnání map. Pro možnost s mapou, byla by třeba tvorba výsledných map ve stejném měřítku a zisk přesné výměry prostředí, ve kterém byla data nahrána. Zvláště informace o přesné podobě prostředí by byla ve velkém množství porovnávání značný problém. Pro tyto účely se tak volí možnost s trajektoriemi, kdy zisk přesné trajektorie pohybu robota, $ground$ $truth$, je výrazně jednodušší.\\
\indent Tvorba trajektorie je u každého systému zcela rozdílná. Nejjednodušší extrakce trajektorie je v případě Hector SLAM. Tato metoda sama publikuje $topic$ s názvem $slam\_out\_pose$, kde je zaznamenávána aktuální pozice. Tím, že Hector SLAM neumí přepisovat předchozí výsledky různými optimalizacemi, či uzavíráním smyčky a informace pouze přidává, může se $slam\_out\_pose$ při běhu implementace celou dobu poslouchat a data z $topicu$ ukládat. Poslouchání $topicu$ je prováděno příkazem \texttt{rostopic echo /topic}, což začne vypisovat data do terminálu. Přidáním za příkaz \texttt{> file.txt} se data uloží do daného soboru. Výsledný příkaz pro uložení trajektorie pomocí Hector SLAM tedy vypadá následovně:
\begin{center}
	\texttt{rostopic echo /slam\_out\_pose > trajectory\_hector.txt}
\end{center}
U metody gMapping je zisk trajektorie složitější. Tato implementace nikam trajektorii nezaznamenává. Jednou z možností, jak ji tedy získat, je využít $node$ obsažený v systému Hector SLAM. Přidáním $node$ s názvem $hector\_trajectory\_server$ do spouštěného souboru $launch$ je tak získána možnost extrahovat trajektorii. Neboť je gMapping systém obsahující optimalizac cesty a mapy a umí uzavírání smyčky, je třeba trajektorii uložit až po doběhnutí dat obsažených v souboru $bag$. Takto se zavolání $topicu$ provádí příkazem \texttt{rosservice call /topic}, uložení do souboru se provede stejně jako v případě s Hector SLAM. Příkaz pro uložení trajektorie má podobu:
\begin{center}
	\texttt{rosservice call /trajectory > trajectory\_gmapping}
\end{center}
Nejsložitější postup zskávání trajektorie je v případě systému Cartographer. Dříve se dala tato informace získat pomocí dvou příkazů. Aktualizací Cartographeru před dvěmi lety však zavedl Google pro ukládání dat nový formát $pbstream$, pro práci s nimž není příliš dobrá veřeně dostupná dokumentace. 
Cartographer při běhu publikuje $node$ s názvem $/trajectory\_node\_list$, který nese v daném časovém okamžiku informaci o všech bodech trajektorie. Při dokončení výpočtů ze spuštěného $bag$ souboru je tedy k uložení dostupná finální trajektorie. Součástí této informace jsou však pouze souřadnice v prostoru a chybí tak informace o natočení, či časovém momentu, kdy robot v daném místě byl. Pro jednodušší porovnání implementací by to stačilo, ale pro správné porovnávání dle (KUMMERLE - On Measuring the Accurancy of SLAM algorithms) by to bylo nedostatečné. Nalezl jsem nakonec soubor od vývojáře pro Google, který dokáže ze souboru $pbstream$ udělat soubor $bag$, ve verzi Cartographeru spravované přímo Googlem ale tento soubor obsažen není. ($https://code.research.uts.edu.au/13110756/cartographer\_ros/blob/master/cartographer\_ros/cartographer\_ros/dev/pbstream\_trajectories\_to\_rosbag\_main.cc$). Využitím tohoto kódu jsem již byl schopen trajektorii získat a to následujícím postupem. Nejprve je třeba nechat proběhnout všechny výpočty z nahraného souboru $bag$, pro lepší orientaci si ho zde označím jako $measured.bag$. Po doběhnutí výpočtů z $measured\_bag$ je potřeba ukončit výpočty Cartographeru zavoláním
\begin{center}
	\texttt{rosservice call /finish\_trajectory 0},
\end{center}
kdy $0$ označuje číslo trajektorie. Tímto příkazem se zahrnou do optimalizace trasy a mapy i částice, na které při doběhnutí dat z $measured.bag$ ještě nedošlo. Následujícím příkazem
\begin{center}
	\texttt{rosservice call /write\_state state.pbstream},
\end{center} 
se uloží aktuální stav Cartographeru do souboru $pbstream$. Poté je třeba se dvěma parametry zavolat přidaný $node$ s názvem $pbstream\_trajectories\_to\_bag$, přičemž první parametr je název souboru $pbstream$ a parametr druhý je název souboru $bag$, do kterého se data uloží. Tento nový $bag$ soubor nazvu jako $processed.bag$. Finálním krokem je z $processed.bag$ získání trajektorie, která je zde uložena v $topicu$ $/tf$. To se provede již použitým příkazem \texttt{rostopic echo /topic}, za který se přidá argument \texttt{-b "bag\_file"}, čímž se řekne, že se nechce poslouchat aktuálně publikovaný $topic$, ale $topic$ z určeného souboru $bag$. Za to se pro uložení do vybraného souboru ještě přidá \texttt{> file.txt}. Výsledný příkaz je tedy v podobě:
\begin{center}
	\texttt{rostopic echo /tf -b processed.bag > trajectory\_cartographer.txt}
\end{center}

\subsubsection{Příprava dat}
Data ze všech systémů jsou v stejném tvaru, počátek mají v bodě [0,0,0], informace o natočení má shodný počátek a i rozsah hodnot, který se pohybuje na intervalu $(0,1\rangle$. Stejně je tomu tak i v případě $ground$ $truth$, s jediným rozdílem, že počátek trajektorie není v bodě [0,0,0]. Úprava tak spočívala v posunutí všech bodů tak, aby byl počátek v tomto bodě.\\
Druhou a poslední úpravou, byla změna intervalu popisující natočení robota. Nově zvolený rozsah je $(-\pi,\pi\rangle$. Důvodem je problém se změnou natočení v okolí hraniční hodnoty. Při hodnotě natočení blízké jedné a otočením se na hodnotu blízké nule, vzniká velký rozdíl hodnot, který nepopisuje vzniklou situaci. S novým intervalem se může přeskočit od hodnoty blízké $\pi$ do hodnoty blízké $-\pi$, což při práci s absolutními hodnotami dává přesnou informaci o změně natočení. 

\newpage

\subsection{Vyhodnocení výsledků}
\subsubsection{Srovnávací kritérium}
Pro srovnání algoritmů SLAM jsem dle (Kummerle) zvolil porovnávací kritérium ve tvaru
\begin{equation}
	\varepsilon(\delta)=\varepsilon_{trans}(\delta)+\varepsilon_{rot}(\delta),
\end{equation}
kde $\varepsilon_{trans}(\delta)$ je chyba určení pozice robota a $\varepsilon_{rot}(\delta)$ je chyba natočení robota.\\
\indent Rovnice pro výpočet chyby pozice se dá dále rozepsat jako:
\begin{equation}
	\varepsilon_{trans}(\delta)=\frac{1}{N}\Sigma_{i,j}trans(\delta_{i,j}\ominus\delta^*_{i,j})^2,
\end{equation}
kde $N$ je celkový počet bodů trajektorie, $\delta_{i,j}$ je relativní pozice robota dle daného algoritmu SLAM v čase $i$ a $j$, přičemž $i$ a $j$ jsou bezprostředně se následující časové záznamy. Pozice v daných časových okamžicích z ground truth je označena jako $\delta^*_{i,j}$. Funkce $trans()$ je určena ve formě Euklidovské normy:
\begin{equation}
	trans(\delta_{i,j}\ominus\delta^*_{i,j})=||\delta_{i,j}\ominus\delta^*_{i,j}||
\end{equation}  
Rovnice pro určení chyby natočení robota je ve tvaru:
\begin{equation}
	\varepsilon_{rot}(\delta)=\frac{1}{N}\Sigma_{i,j}rot(\delta_{i,j}\ominus\delta^*_{i,j})^2,
\end{equation}
kde všechny proměnné mají stejný význam jako u chyby určení pozice a funkce $rot()$ má předpis:
\begin{equation}
	rot(\delta_{i,j}\ominus\delta^*_{i,j})=|min(2\pi-|\delta_{i,j}\ominus\delta^*_{i,j}|,|\delta_{i,j}\ominus\delta^*_{i,j}|)|
\end{equation}
Tento přístup, narozdíl od běžného porovnávání vzdálenosti bodů v prostoru, nehledí na přímý rozdíl pozice bodů v daném čase, ale na změnu relativních pozic v časovém úseku. 

\newpage
\subsubsection{Porovnání výsledků ze Stage}
Pro porovnání výsledků, nahraných pomocí rozhraní Stage, jsem si vytvořil několik obrázkových map. Přesnost algoritmů byla u všech map přibližně stejná. Názorné porovnání jsem tedy udělal pouze na jedné, kde při průjezdu vznikly dvě smyčky. K porovnání jsem využil rovnice z předchozí sekce.\\
\begin{center}
	\begin{tabular}{c|ccp{3cm}}
		\bfseries \bfseries  & $\varepsilon_{trans}(\delta)$ $[m]$ & $\varepsilon_{rot}(\delta)$ $[rad]$ & $\varepsilon(\delta)$  \\ [2mm]
		\hline
		Cartographer & $0.00086$ & $0.00062$ & $0.00149$  \\
		GMapping & $5.7225\times10^{-5}$ & $4.45249\times10^{-5}$ & $0.00010$  \\ 
		Hector & $4.12745\times10^{-5}$ & $0.00023$ & $0.00027$  \\ 
	\end{tabular}
\end{center}

Z výsledků je zřejmé, že všechny algoritmy proběhly v pořádku a s vysokou přesností. Nejlepších výsledků v tomto případě dosáhl systém gMapping. Byla zde i prokázána důležitost zvoleného kritéria porovnávání. Například při srovnání trajektorií pomocí metody $Root$ $Mean$ $Square$ $Error$ (RMSE) dosáhl nejlepších výsledků algoritmus Hector SLAM. RMSE je porovnání trajektorií, kde se počítá pouze s rozdílem bodů v daném časovém okamžiku. 

\newpage
\subsubsection{Porovnání výsledků nahraných robotem}
Data jsem pro toto porovnání nahrával v pátém patře budovy Fakulty aplikovaných věd ZČU v části NTIS. Jak jsem již výše zmínil, odometrie zaznamenána robotem je v tomto případě nepoužitelná. Přesto, že vše v něm nahrané je nastaveno dle specifikace výrobce, informace je velmi nepřesná. Robot sám při jízdě dopředu lehce zatáčí doprava. Informace o dopředném pohybu je ale jinak ukládána správně, při zatáčení však robot zaznamenává informaci o mnohem větším zatočení, než k jakému došlo. Ztráta odometrie má na každý ze systémů rozídlný dopad.\\
\indent Hector SLAM, který odometrickou informaci vůbec nepoužívá, není tedy tímto omezením nijak ovlivněn a jeho průběh je standardní. Cartographer již odometrii využívá, lze ale vypnout sledování odometrie a používat odometrii systémem dopočítávanou. Použitím tohoto nastavení se Cartographer stává náchylný na podlouhlé prostory bez větších rodílů, typickým příkladem jsou chodby. GMapping bezpodmíněčně odometrickou informaci vyžaduje. Informace silně zkreslená tak průběh programu velmi komplikuje.\\
\indent Při pohledu na vytvořené mapy je znát nedostatek s odometrií pouze u Cartographeru, kdy jedno projetí celého prostoru bylo nedostatečné a mapa není na pohled příliš kvalitní. Pro srovnání jsem však nahrál ještě nový dataset, kdy jsem projel daný prostor dvakrát a výsledek je znatelně lepší.\\
\indent Pohled na trajektorie je však již více vypovídající o nedostatcích spojených s nekvalitní odometrickou informací. Pro Hector SLAM se opět nic neměnilo a trajektorie je v pořádku. U Cartographeru je vidět, že kvůli občasným problémům s rozeznáním posunu po chodbách, je trajektorie značně kratší. Největší problém v oblasti trajektorie je znatelný u systému gMapping, kdy informace o přetáčení vytváří na trajektorii po celou dobu velké výchylky a zuby. Algoritmus si s tím však dokáže i tak poradit a výsledná mapa tím ovlivněna není.\\
\indent Bez znalosti $ground$ $truth$ musím porovnat algoritmy pomocí získaných map. Měřením poměru vzdáleností mezi jednotivými body v prostoru a porovnáním s těmito body ve vytvořených mapách, vyhodnocuji pro tento případ jako nejlepší algoritmus Hector SLAM, v těsném závěsu poté gMapping. 

\newpage 
\subsubsection{Porovnání výsledků ze staženého datasetu}
Pro porovnání systémů byla potřeba najít dataset, který v sobě obsahuje všechny potřebné informace pro jejich vykonání. Další podmínkou, která musela být splněna, aby testování mělo srovnatelné výsledky, je nutnost znalosti $ground$ $truth$ pro daná data. Potřebné informace obsahují datasety nahrané v MIT Stata Center, kde k mnohým z nich je možno ještě stáhnout $ground$ $truth$. Pro porovnání tak byl zvolen jeden z těchto datasetů.\\
\indent $Ground$ $truth$ má rovnou informaci o natočení v rozsahu $(-\pi,\pi\rangle$, nebyla v tomto tedy potřeba žádná změna. Data však byla natočená přibližně o 30$^o$ a posunuta mimo počátek [0,0,0]. Stažená data byla tedy přepočítána tak, aby bylo natočení a počátek stejný. Porovnávání pak bylo provedeno dle rovnic v sekci Srovnávací kritérium REFERENCE.\\
\begin{center}
	\begin{tabular}{c|ccp{3cm}}
		\bfseries \bfseries  & $\varepsilon_{trans}(\delta)$ $[m]$ & $\varepsilon_{rot}(\delta)$ $[rad]$ & $\varepsilon(\delta)$  \\ [2mm]
		\hline
		Cartographer & $0.00049$ & $0.00148$ & $0.00197$  \\
		GMapping & $0.02002$ & $0.00698$ & $0.02701$  \\ 
		Hector & $0.00860$ & $0.00144$ & $0.01005$  \\ 
	\end{tabular}
\end{center}

Z výsledků je patrné, že v tomto případě si nejlépe vedl Cartographer. Za ním je dle tabulky Hector SLAM a poslední je gMapping. Při pohledu na mapu je však vidět, že trajektorie Hector SLAMu je neúplná a na konci silně vychýlená. Je to z důvodu, že při průjezdu předcházejícím výběžkem, došlo vždy k dislokaci robota, následně i v dalších částech měl problémy v orientaci i přes změny v řadě nastavení. Trajektorie Hector SLAMu by tak byla pro porovnání naprosto nevyhovující a je proto ukončena v bodě, do kterého se systém ještě fungoval správně.\\
\indent Výše zmíněné výsledky a mapa, jsou však získány z datasetu, kterému byla zmenšena obsažená data. Respektive jsou od určitého času ustřižena. Důvod byl, že i přes nastavení Cartographeru určené pro tyto data, nedokázal si tento systém částečně poradit s jednou chodbou a došlo tak k posunu velké části trajektorie a mapy. Výsledky z celého datasetu jsou následující.\\
\begin{center}
	\begin{tabular}{c|ccp{3cm}}
		\bfseries \bfseries  & $\varepsilon_{trans}(\delta)$ $[m]$ & $\varepsilon_{rot}(\delta)$ $[rad]$ & $\varepsilon(\delta)$ \\ [2mm]
		\hline
		Cartographer & $0.00292$ & $0.00158$ & $0.00451$ \\
		GMapping & $0.02601$ & $0.00831$ & $0.03432$ \\ 
	\end{tabular}
\end{center}

Je vidět, že výsledky se u obou porovnávaných systémů mírně zhoršily, chyba v pozici u Cartographeru poté výrazněji, což je zaviněno zmíněným posunem. I tak má však Cartographer opět lepší výsledek, neboť srovnávací kritérium nepočítá rozdíl jednotlivých bodů od sebe, ale poměřuje přírůstek mezi dvěma časovými okamžiky. Přechody v trajektorii jsou u Cartographeru tedy přesnější, než ty u gMappingu. 

\section{Průzkum vybraného systému}
Pro důkladnější prozkoumání vybraného systému byl zvolen gMapping, neboť je komplexnější než Hector SLAM a předhlednější než Cartographer. Při běhu má také nejmenší sklony k poruchám. Pro bližší seznámení a případné návrhy změn vychází tedy nejlépe.

\subsection{Změny v konfiguraci systému}
V předchozích měřeních bylo vždy použito defaultní nastavení systému. Toto nastavení nebylo třeba měnit, neboť gMapping vždy provedl výpočty dle očekávání a nikdy se nestalo, že by jako jediný selhal.\\
\indent Pro zkoumání vlivu nastavení na systém, byly postupně měněny různé parametry. Pro testovací data byl zvolen zkrácený dataset z MIT Stata Center.\\
\indent Pro tyto účely byla přidána ke srovnání ještě jedna rovnice, porovnávající přímo polohu jednotlivých bodů trajektorie s $ground$ $truth$. Rovnice je ve tvaru
\begin{equation}
	e(t,g)=\sqrt{\frac{1}{N}\Sigma_i(||t_i-g_i||)^2},
\end{equation}
kde $t$ je vypočtená trajektorie, $g$ je $ground$ $truth$, $N$ je počet vzorků trajektorie a $i$ udává časový okamžik.\\
\indent V násedující tabulce jsou defaultní hodnoty parametrů, které byly upraveny pro účely porovnání.
\begin{center}
	\begin{tabular}{c|p{3cm}}
		\bfseries Parametr  & \bfseries Hodnota  \\ [2mm]
		\hline
		$lstep$ & $0.05$ \\
		$astep$ & $0.05$ \\
		$iterations$ & $5$ \\
		$ogain$ & $3.0$ \\
		$linearUpdate$ & $1.0$ \\
		$angularUpdate$ & $0.5$ \\
		$resampleThreshold$ & $0.5$ \\
		$particles$ & $5$ \\
		$llsamplerange$ & $0.01$ \\
		$llsamplestep$ & $0.01$ \\
		$lasamplerange$ & $0.005$ \\
		$lasamplestep$ & $0.005$ \\
	\end{tabular}
\end{center}
\newpage
Výsledky jsou následující.
\begin{center}
	\begin{tabular}{c|cccp{3cm}}
		\bfseries \bfseries  & $\varepsilon_{trans}(\delta)$ $[m]$ & $\varepsilon_{rot}(\delta)$ $[rad]$ & $\varepsilon(\delta)$ & $e(t,g)$ \\ [2mm]
		\hline
		GMapping 1 & $0.02002$ & $0.00698$ & $0.02701$ & $1.61581$\\
		GMapping 2 & $0.01626$ & $0.00537$ & $0.02164$ & $2.52559$\\ 
		GMapping 3 & $0.00945$ & $0.00566$ & $0.01512$ & $1.79921$\\ 
		GMapping 4 & $0.00911$ & $0.00558$ & $0.01469$ & $3.27171$\\ 
		GMapping 5 & $0.00902$ & $0.00551$ & $0.01453$ & $1.84911$\\ 
		GMapping 6 & $0.00903$ & $0.00543$ & $0.01446$ & $1.74181$\\ 
		GMapping 7 & $0.01997$ & $0.00641$ & $0.02639$ & $1.85808$\\ 
	\end{tabular}
\end{center}

Každé nastavení, na kterém byl gMapping spuštěn, vychází v defaultního, je vždy změněno několik parametrů spolu souvisejících. První výpočet byl proveden s defaultním nastavením a shoduje se tak s výsledkem při porovnání všech tří systémů. V druhém případě byly změněny parametry $lstep$ a $astep$, které určují optimalizační krok pro pohyb $lstep=1$ a rotaci $astep=1$. Při třetím pokusu byl pozměněn počet iterací porovnávání pozorování $iterations=2$ a parametr $ogain$, který udává hodnotu pro vyhodnocování pravděpodobnosti, použitou při převzorkování, $ogain=1.0$. Pro čtvrtý výpočet byly pozměněny kritéria, kdy robot provádí nové pozorování. Pro ujetou vzdálenost $linearUpdate=4.0$ a pro otočení $angularUpdate=1.0$. Pro pátý pokus byl změněn parametr udávající, při jakém procentu zbylých částic má dojít k převzorkování, $resampleThreshold=0.1$. Při šestém výpočtu byl pozměněn počet částic ve filtru, $particles=5$. Pro poslední pokus pak byly změněny parametry pro translační a úhlové vzorkování použité pro pravděpodobnost, $llsamplerange=0.1$, $llsamplestep=0.1$, $lasamplerange=0.05$ a $lasamplestep=0.05$.\\
\indent Z výsledků je patrný vliv nastavení na výpočet dat. Porovnáním dle (Kummerle) je dosaženo pro defaultní nastavení překvapivě nejhorších výsledků. Zlepšení u jiných nastavení nejsou rozdílná v řádu, tudíž ne tak zásadní. Při pohledu na výpočet chyby $e(t,g)$ je však dosaženo rozdílných výsledků a defaultní nastavení je s tímto kritériem porovnání nejlepší.\\
\indent Z těchto informací lze dojít k závěru, že systém je nastavený tak, aby dosahoval nejpřesnější trajektorie z pohledu vzorek v trajektorii ku vzorku v $ground$ $truth$. Ziskem takové trajektroie pak může systém vytvořit nejpřesnější reprezentaci prostředí. Další věcí je, že gMapping sám o sobě extrahovatelnou trajektorii neposkytuje. Tvůrci systému se tedy pravděpodobně ani příliš nesnažili, aby v nějakém podobném testování implementací, jako například (Kummerle) gMapping dosahoval nejlepších výsledků. 

\newpage
\subsection{Návrh změn v systému}
Jako první věc, kterou je dobré uvést, je výše zmíněná neprodukce extrahovatelné trajektorie. Jako řešení se zde nabízí přidání topiku, který bude mít podobnou strukturu jako $/trajectory\_node\_list$ v Cartographeru. Tento topik, jak je popsáno v kapitole (Uložení trajektorie), nemá však pro potřebné porovnávání dostatek informací. Pro případ gMappingu by tak mohl být publikován topik, který by posílal v daném čase informaci o aktuální trajektorii. Obsah topiku by tak obsahoval vždy hlavu, ve které by byl uvedený aktuální čas. K tomu by byly připojeny pod sebou dle času seřazené částice tvořící aktuální trjaketorii. K těmto částicím by byla přidružena vždy informace o simulačním čase, kdy byla částice vytvořena, její souřadnice v prostoru a informace o natočení. Při poslouchání topiku v průběhu programu by tak bylo možné i získat srovnání, jak se trajektorie v průběhu času optimalizovala. Při zavolání po doběhnutí datasetu by pak byla poskytnuta rovnou hotová trajektorie.\\
\indent Další prospěšnou změnou by pro systém byla určitě možnost upravovat parametry za běhu programu. Pro výše provedené testy nebyla taková úprava potřeba, neboť se ať reálný nebo simulační robot pohybovali po celou dobu ve stejném prostředí. Při uvážení, že by se však robot přemisťoval mezi uzavřenými a otevřenými prostory, tato mořnost by byla jistě užitečná. Při běžněm průběhu, kdy uživatel robotem sám jezdí, může program vypnout a spustit gMapping s jiným nastavením, což není příliš hezké řešení. Pro autonomního robota by to však mohl být větší problém. V případě, že vyjede do jiného typu prostředí mohl by si sám přenastavit parametry tak, aby odpovídali již někde uloženému nastavení pro dané prostředí.\\
\indent Další potenciální změnou, která se již nevztahuje přímo k procesům v gMappingu, by byla integrace kamerového vidění, například monokulární kamery. Robot by snímal prostředí jak LIDARem, tak kamerou. V případě kamerových dat by se snažil rozeznat předměty v prostoru a následně předat informaci o tom, jaký typ předmětu to je. Například při detekci židle by byla vyslána informace, že se daný předmět nemá zanášet do mapy, případně z mapy vymazat. Do místa, kde je židle postavena, by se ještě přidala značka substituující židli. Při opětovném projetí by pak robot věděl, že v daném místě by se mohla židle nacházet a v případě, že tam stále nějaký předmět je, rovnou se snažit ho označit jako židli. Při velké množině objektů v paměti by se tak ušetřilo mnoho výpočetního výkonu. "Pohyblivé" předměty jsou v mapě navíc a při jejich přemístění může mít robot problém poznat stejné místo. Pokud by tedy v mapě zaneseny nebyly a robot měl opět jak LIDAR, tak kameru, sám by opět vyhodnotil, že předměty jsou v prostoru navíc, a počítal by tak s mapou předměty neobsahující. Pokud by mu tak byla poskytnuta mapa nějakého takto vyčištěného prostředí, byl by v něm schopen určit svoji pozici bez ohledu na předměty, které v daném prostoru již vůbec nejsou, jsou přemístěny nebo se tam dříve ani nenacházeli.

\newpage
\section{Závěr}

\end{document}